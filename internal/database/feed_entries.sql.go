// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: feed_entries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFeedEntry = `-- name: CreateFeedEntry :exec
INSERT INTO feed_entries(entry_id, feed_id)
  VALUES ($1, $2)
ON CONFLICT (feed_id, entry_id)
  DO NOTHING
RETURNING
  feed_id, entry_id, has_read
`

type CreateFeedEntryParams struct {
	EntryID int32
	FeedID  int32
}

func (q *Queries) CreateFeedEntry(ctx context.Context, arg CreateFeedEntryParams) error {
	_, err := q.db.Exec(ctx, createFeedEntry, arg.EntryID, arg.FeedID)
	return err
}

const getFeedEntry = `-- name: GetFeedEntry :one
SELECT
  feed_id, entry_id, has_read
FROM
  feed_entries
WHERE
  feed_id = $1
  AND entry_id = $2
`

type GetFeedEntryParams struct {
	FeedID  int32
	EntryID int32
}

func (q *Queries) GetFeedEntry(ctx context.Context, arg GetFeedEntryParams) (FeedEntry, error) {
	row := q.db.QueryRow(ctx, getFeedEntry, arg.FeedID, arg.EntryID)
	var i FeedEntry
	err := row.Scan(&i.FeedID, &i.EntryID, &i.HasRead)
	return i, err
}

const listFeedEntries = `-- name: ListFeedEntries :many
SELECT
  e.id, e.link, e.title, e.published_at, e.author, e.content, e.thumbnail_url,
  fe.feed_id, fe.entry_id, fe.has_read,
  count(*) OVER () AS total_count
FROM
  feed_entries fe
  JOIN entries e ON e.id = fe.entry_id
WHERE
  CASE WHEN $1 THEN
    fe.feed_id = $2
  ELSE
    TRUE
  END
  AND CASE WHEN $3 THEN
    fe.has_read = $4
  ELSE
    TRUE
  END
ORDER BY
  e.published_at DESC
LIMIT $6 OFFSET $5
`

type ListFeedEntriesParams struct {
	FilterByFeedID  interface{}
	FeedID          int32
	FilterByHasRead interface{}
	HasRead         bool
	Offset          int32
	Limit           pgtype.Int4
}

type ListFeedEntriesRow struct {
	Entry      Entry
	FeedEntry  FeedEntry
	TotalCount int64
}

func (q *Queries) ListFeedEntries(ctx context.Context, arg ListFeedEntriesParams) ([]ListFeedEntriesRow, error) {
	rows, err := q.db.Query(ctx, listFeedEntries,
		arg.FilterByFeedID,
		arg.FeedID,
		arg.FilterByHasRead,
		arg.HasRead,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedEntriesRow
	for rows.Next() {
		var i ListFeedEntriesRow
		if err := rows.Scan(
			&i.Entry.ID,
			&i.Entry.Link,
			&i.Entry.Title,
			&i.Entry.PublishedAt,
			&i.Entry.Author,
			&i.Entry.Content,
			&i.Entry.ThumbnailUrl,
			&i.FeedEntry.FeedID,
			&i.FeedEntry.EntryID,
			&i.FeedEntry.HasRead,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFeedEntry = `-- name: UpdateFeedEntry :one
UPDATE
  feed_entries
SET
  has_read = coalesce($1, has_read)
WHERE
  feed_id = $2
  AND entry_id = $3
RETURNING
  feed_id, entry_id, has_read
`

type UpdateFeedEntryParams struct {
	HasRead pgtype.Bool
	FeedID  int32
	EntryID int32
}

func (q *Queries) UpdateFeedEntry(ctx context.Context, arg UpdateFeedEntryParams) (FeedEntry, error) {
	row := q.db.QueryRow(ctx, updateFeedEntry, arg.HasRead, arg.FeedID, arg.EntryID)
	var i FeedEntry
	err := row.Scan(&i.FeedID, &i.EntryID, &i.HasRead)
	return i, err
}
