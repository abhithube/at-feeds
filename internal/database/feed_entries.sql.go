// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: feed_entries.sql

package database

import (
	"context"
	"database/sql"
)

const countFeedEntries = `-- name: CountFeedEntries :one
SELECT
  COUNT(*) AS count
FROM
  feed_entries
WHERE
  CASE WHEN ?1 THEN
    feed_id = ?2
  ELSE
    TRUE
  END
  AND CASE WHEN ?3 THEN
    has_read = ?4
  ELSE
    TRUE
  END
`

type CountFeedEntriesParams struct {
	FilterByFeedID  interface{}
	FeedID          int64
	FilterByHasRead interface{}
	HasRead         int64
}

func (q *Queries) CountFeedEntries(ctx context.Context, arg CountFeedEntriesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countFeedEntries,
		arg.FilterByFeedID,
		arg.FeedID,
		arg.FilterByHasRead,
		arg.HasRead,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFeedEntry = `-- name: GetFeedEntry :one
SELECT
  feed_id, entry_id, has_read
FROM
  feed_entries
WHERE
  feed_id = ?1
  AND entry_id = ?2
`

type GetFeedEntryParams struct {
	FeedID  int64
	EntryID int64
}

func (q *Queries) GetFeedEntry(ctx context.Context, arg GetFeedEntryParams) (FeedEntry, error) {
	row := q.db.QueryRowContext(ctx, getFeedEntry, arg.FeedID, arg.EntryID)
	var i FeedEntry
	err := row.Scan(&i.FeedID, &i.EntryID, &i.HasRead)
	return i, err
}

const listFeedEntries = `-- name: ListFeedEntries :many
SELECT
  feed_id, entry_id, has_read, id, link, title, published_at, author, content, thumbnail_url,
  count(*) OVER () AS total_count
FROM
  feed_entries fe
  JOIN entries e ON e.id = fe.entry_id
WHERE
  CASE WHEN ?1 THEN
    fe.feed_id = ?2
  ELSE
    TRUE
  END
  AND CASE WHEN ?3 THEN
    fe.has_read = ?4
  ELSE
    TRUE
  END
ORDER BY
  e.published_at DESC
LIMIT ?6 OFFSET ?5
`

type ListFeedEntriesParams struct {
	FilterByFeedID  interface{}
	FeedID          int64
	FilterByHasRead interface{}
	HasRead         int64
	Offset          int64
	Limit           int64
}

type ListFeedEntriesRow struct {
	FeedID       int64
	EntryID      int64
	HasRead      int64
	ID           int64
	Link         string
	Title        string
	PublishedAt  string
	Author       sql.NullString
	Content      sql.NullString
	ThumbnailUrl sql.NullString
	TotalCount   int64
}

func (q *Queries) ListFeedEntries(ctx context.Context, arg ListFeedEntriesParams) ([]ListFeedEntriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeedEntries,
		arg.FilterByFeedID,
		arg.FeedID,
		arg.FilterByHasRead,
		arg.HasRead,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedEntriesRow
	for rows.Next() {
		var i ListFeedEntriesRow
		if err := rows.Scan(
			&i.FeedID,
			&i.EntryID,
			&i.HasRead,
			&i.ID,
			&i.Link,
			&i.Title,
			&i.PublishedAt,
			&i.Author,
			&i.Content,
			&i.ThumbnailUrl,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFeedEntry = `-- name: UpdateFeedEntry :one
UPDATE
  feed_entries
SET
  has_read = coalesce(?1, has_read)
WHERE
  feed_id = ?2
  AND entry_id = ?3
RETURNING
  feed_id, entry_id, has_read
`

type UpdateFeedEntryParams struct {
	HasRead sql.NullInt64
	FeedID  int64
	EntryID int64
}

func (q *Queries) UpdateFeedEntry(ctx context.Context, arg UpdateFeedEntryParams) (FeedEntry, error) {
	row := q.db.QueryRowContext(ctx, updateFeedEntry, arg.HasRead, arg.FeedID, arg.EntryID)
	var i FeedEntry
	err := row.Scan(&i.FeedID, &i.EntryID, &i.HasRead)
	return i, err
}

const upsertFeedEntry = `-- name: UpsertFeedEntry :exec
INSERT INTO feed_entries(entry_id, feed_id)
  VALUES (?1, ?2)
ON CONFLICT (feed_id, entry_id)
  DO NOTHING
`

type UpsertFeedEntryParams struct {
	EntryID int64
	FeedID  int64
}

func (q *Queries) UpsertFeedEntry(ctx context.Context, arg UpsertFeedEntryParams) error {
	_, err := q.db.ExecContext(ctx, upsertFeedEntry, arg.EntryID, arg.FeedID)
	return err
}
